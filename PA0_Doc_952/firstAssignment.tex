\newpage
\section
{
\textbf{ {\Large 
بخش سوم: تمارین مقدماتی
}}}

\subsection{make}
احتمالا از gcc برای کامپایل برنامه هایتان استفاده می کنید. اما این کار وقتی تعداد فایلها افزایش یابد پیچیده و خسته کننده می شود. برای این تمرین نیاز دارید که یک Makefile بنویسید که با اجرای دستور make، فایلهای main.c، wc.c و map.c را کامپایل کند (ممکن است برای این مرحله پرچم -g gcc نیاز پیدا کنید). همچنین ممکن است این کمک کند که یک clean target (برای make clean) بنویسید که binaryهایتان را پاک کند، البته این قسمت اختیاری است.

\subsection{wc}
اولین اقدامی که باید انجام دهید این است که یک clone از ابزار wc بنویسید که تعداد خطوط، کلمات و کاراکترهای یک فایل text را بشمارد. میتوانید wc خود را در ماشین مجازی اجرا کنید تا ببینید خروجی باید شبیه به چه فرمتی باشد، سپس تلاش کنید که از عملکردهای\LTRfootnote{functionality} اصلی در wc.c تقلید کنید (از بابت پرچمها و فاصله گذاری ها در خروجی نگران نباشید).
تنها نیاز دارید که اجرای “wc FILE_NAME” و wc(که باید داده را از ورودی استاندارد بخواند) را support کنید.
در طول مدت زمانی که درحال کار روی این بخش هستید توصیه می شود نهایت استفاده را از gdb ببرید.

\subsection{فایلهای اجرایی و آدرسها}
\subsubsection{
\lr{gdb}
}
فایل اجرایی wc خود را در gdb با یک فایل ورودی از طریق آرگومان خط فرمان بار\LTRfootnote{load} کنید. سپس نقطه وقفه ای روی main بگذارید و برنامه را شروع کنید. فرآیند اجرا را تا زمانی که در میانه ی اجرای برنامه هستید خط به خط ادامه دهید. با استفاده از \begin{flushleft}
\code{where}
\end{flushleft} یا \begin{flushleft}
\code{backtrace (bt)}
\end{flushleft} پشته\LTRfootnote{stack} را بررسی کنید.
هنگامی که درحال استفاده از gdb هستید به سوالات زیر فکر کنید و پاسخ را در فایل gdb.txt قرار دهید.
\begin{itemize}
\item
مقدار argv چند است؟(راهنمایی: print argv)
\item
argv به کجا اشاره می کند؟(راهنمایی: print argv[0])
\item
آدرس تابع main چیست؟
\item
دستور info stack را اجرا کنید و مشاهدات خود را بیان کنید.
\item
دستور info frame را اجرا کنید و مشاهدات خود را بیان کنید.
\item
دستور info registers را اجرا کنید. کدام رجیسترها ویژگیهای برنامه ای که می شناسید را در بر دارد؟
\end{itemize}

\subsubsection{
\lr{objdump}
}
برای آنکه جزئیات بیشتری از برنامه تان را ببینید کافی است برای مثال دستور \begin{flushleft}
\code{objdump -x -d wc}
\end{flushleft} را اجرا کنید. پس از اجرای این دستور مشاهده می کنید که برنامه چندین سگمنت دارد و نام توابع و متغیرهای برنامه به همراه آدرسها و مقادیر نظیرشان نمایش داده می شوند. در خروجی objdump این سگمنتها زیر بخش\LTRfootnote{section} heading قرار دارند.
هنگامی که درحال استفاده از objdump هستید به سوالات زیر فکر کنید و پاسخ را در فایل objdump.txt قرار دهید.
\begin{itemize}
\item
از چه فرمت فایلی برای این باینری استفاده می شود؟ و برای چه معماری کامپایل می شود؟
\item
تعدادی از نامهای سگمنتها/بخشهایی که یافتید را نام ببرید.
\item
چه سگمنت/بخشی در بردارنده تابع main است؟ و آدرس main چیست؟ (میبایست همان آدرسی باشد که در gdb مشاهده کدرید)
\item
آیا سگمنتی که مربوط به پشته یا heap باشد را مشاهده کردید؟ چگونه؟
\end{itemize}

\subsubsection{
\lr{map}
}
حال شما قادرید یک برنامه را که ساختار اجرایی خود را نشان دهد بنویسید. فایل دومی که در hw0 قرار دارد(map.c) یک ساختار تقریبا کامل را فراهم می کند. شما نیاز دارید که این فایل را به گونه ای تغییر دهید که آدرسهایی که به دنبالشان می گردید را پیدا کنید. خروجی این قسمت شبیه زیر است (آدرسها ممکن است تفاوت داشته باشند).
\begin{flushleft}
\code{_main  @ 0x4005c2
recur @ 0x40057d
_main stack: 0x7fffda11f73c
static data: 0x601048
Heap: malloc 1: 0x671010
Heap: malloc 2: 0x671080
recur call 3: stack@ 0x7fffda11f6fc
recur call 2: stack@ 0x7fffda11f6cc
recur call 1: stack@ 0x7fffda11f69c
recur call 0: stack@ 0x7fffda11f66c
}
\end{flushleft}

حال به سوالات زیر فکر کنید و پاسخ را در فایل map.txt قرار دهید.
\begin{itemize}
\item
از objdump با پرچم -D روی فایل اجرایی map استفاده کنید. کدام آدرسها از خروجی اجرای ./map در فایل اجرایی تعریف شده اند؟ و هریک در چه سگمنت/بخش؟
\item
لیستی از سگمنتهای مهم و کاربردشان تهیه کنید.
\item
پشته در چه جهتی افزایش می یابد؟
\item
stack frame برای هر فراخوانی بازگشتی\LTRfootnote{recursive} چقدر است؟
\item
آیا دو ناحیه از حافظه که malloc شده اند پیوسته اند؟(فضای آدرسی اضافی مابین آنها قرار ندارد؟)
\item
\end{itemize}

\subsection{محدودیتهای کاربر}
سیستم عامل میبایست با سایز سگمنتهایی نظیر پشته و heap به دلیل پویای آنها هماهنگ باشد. سایز آنها چه مقدار باید باشد؟ کمی جستجو کنید و ببینید که این محدودیتها روی linux چگونه set و get می شوند.
main.c را به گونه ای تغییر دهید که بیشینه سایز پشته، بیشینه تعداد پردازه ها و بیشینه تعداد توصیفگرهای فایل را چاپ کند. درحال حاضر اگر آنرا اجرا کنید مشاهده می کنید که قسمتی از محدودیتهای منابع سیستم را چاپ می کند(stack size, heap size, ...). متاسفانه تمامی این مقادیر صفر هستند و شما باید کاری کنید که این اعداد مقادیر واقعی باشند. برای این کار میتوانید از soft limitها به جای hard limitها استفاده کنید.(راهنمایی: دستور “man getrlimit” را اجرا کنید.)
خروجی مورد انتظار باید شبیه زیر باشد:
\begin{flushleft}
\code{stack size: 8388608
process limit: 2782
max file descriptors: 1024}
\end{flushleft}